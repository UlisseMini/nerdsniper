SEARCH_SQL_TEMPLATE = '''
WITH results AS (
  SELECT id, username, name, description, textsearchable

  FROM users
  WHERE textsearchable @@ plainto_tsquery($1)
  {where}
  LIMIT {limit}
)

SELECT id, username, name, description
FROM results
ORDER BY ts_rank(textsearchable, plainto_tsquery($1))
'''.strip()

LIMIT = 100

class ParseError(Exception):
    pass


def parse_query(*args, **kwargs):
    try:
        return _parse_query(*args, **kwargs)
    except Exception as e:
        raise ParseError(repr(e))



def parse_gt_le(val):
    print(val)
    op = val[0]
    if op not in '><':
        raise ParseError('invalid operator: {} (valid are < and >)'.format(op))

    try:
        n = int(val[1:])
    except ValueError as e:
        raise ParseError('invalid integer: {}'.format(val[1:]))

    return op, n



def _followers(val, sql, where):
    """
    followers:>100 or followers:<100
    search for people with a specific number of followers
    """

    op, n = parse_gt_le(val)
    where += 'AND followers_count {} {}'.format(op, n)
    return sql, where


def _following(val, sql, where):
    """
    following:>100 or following:<100
    search for people based on how many people they follow
    """

    op, n = parse_gt_le(val)
    where += 'AND following_count {} {}'.format(op, n)
    return sql, where

def _tweet_count(val, sql, where):
    """
    tweets:>100 or tweets:<100
    search for people based on how many tweets they've posted
    """

    op, n = parse_gt_le(val)
    where += 'AND tweet_count {} {}'.format(op, n)
    return sql, where


modifiers = {
    'followers': _followers,
    'following': _following,
    'tweets': _tweet_count
}

# stur the soup of metaprogramming
docs = ''

for fn in modifiers.values():
    assert fn.__doc__ is not None

    doc = fn.__doc__.strip()
    doc = doc.replace('>', '&gt;')
    doc = doc.replace('<', '&lt;')
    doc = doc.replace('\n', '\n<br>\n')

    docs += doc + '\n<br><br>\n'

# if you think this is bad, go read the autogenerated integration tests.


# note: somewhat tollerable parser, if something *might* be a syntax error
# we let it through.
# we return (sql, args) where args is a list to be passed through asyncpg
# for serialization
def _parse_query(query: str) -> (str, str):
    sql = SEARCH_SQL_TEMPLATE

    where = ''
    query_raw = ''

    tokens = query.split(' ')
    for token in tokens:
        a = token.split(':')
        if len(a) != 2:
            query_raw += token
            continue


        stmt, val = a
        if modifiers.get(stmt) is not None:
            sql, where = modifiers[stmt](val, sql, where)



    return sql.format(limit=LIMIT, where=where), [query_raw]
