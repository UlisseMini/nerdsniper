import markdown2
import string

SEARCH_SQL_TEMPLATE = '''
WITH results AS (
  SELECT id, username, name, description, textsearchable

  FROM users
  WHERE {search} {where}
  LIMIT {limit}
)

SELECT id, username, name, description
FROM results
{orderby}
'''.strip()

LIMIT = 100

class ParseError(Exception):
    pass


def parse_query(*args, **kwargs):
    try:
        return _parse_query(*args, **kwargs)
    except Exception as e:
        raise ParseError(repr(e))



def parse_gt_le(val):
    op = val[0]
    if op not in '><':
        raise ParseError('invalid operator: {} (valid are < and >)'.format(op))

    try:
        n = int(val[1:])
    except ValueError as e:
        raise ParseError('invalid integer: {}'.format(val[1:]))

    return op, n



def _followers(val, sql, where):
    """
    followers:>100 or followers:<100
    search for people with a specific number of followers
    """

    op, n = parse_gt_le(val)
    where += '\nAND followers_count {} {}'.format(op, n)
    return sql, where


def _following(val, sql, where):
    """
    following:>100 or following:<100
    search for people based on how many people they follow
    """

    op, n = parse_gt_le(val)
    where += '\nAND following_count {} {}'.format(op, n)
    return sql, where

def _tweet_count(val, sql, where):
    """
    tweets:>100 or tweets:<100
    search for people based on how many tweets they've posted
    """

    op, n = parse_gt_le(val)
    where += '\nAND tweet_count {} {}'.format(op, n)
    return sql, where


def _gender(val, sql, where, conf = 0.7):
    """
    gender:F or gender:M or gender:F,0.7
    search for people based on predicted gender, optionally specify
    how confident my algorithm should be. (default confidence: 0.7)
    """

    args = val.split(',')
    args[0] = args[0].upper()
    if args[0] not in 'FM':
        raise ParseError('there are only two genders')

    if len(args) > 1:
        conf = float(args[1])
        if conf > 1 or conf < 0:
            raise ParseError('confidence must be in range 0-1')


    if args[0] == 'M':
        conf = 1 - conf


    # We do this cancerous dance because I coulden't figure out how to
    # make ranges go fast, so we make our own fucking ranges
    # (dtype in DB is numeric(2, 1))
    any_of = []
    if args[0] == 'F':
        any_of = [x*0.1 for x in range(round(conf*10), 11)]
    else:
        any_of = [x*0.1 for x in range(0, round(conf*10) + 1)]


    _s = lambda n: str(round(n, 1))
    where += '\nAND P_female IN ({})'.format(','.join(map(_s, any_of)))
    return sql, where


def _lang(val, sql, where):
    """
    lang:en, lang:jp etc
    filter results based on user language, supported languages are listed [here](https://developer.twitter.com/en/docs/twitter-api/v1/developer-utilities/supported-languages/api-reference/get-help-languages#example-response)
    """
    val = val.lower()

    # please uli be careful editing this code sqli is looming
    # (todo: check that language actually exists, could get langs from db at startup
    #  once I refactor schema to use an enum with num index like a smart boi)
    if not all(c in string.ascii_lowercase+'-' for c in val):
        raise ParseError(f'Invalid language: {val}')

    where += f"\nAND lang='{val}'"

    return sql, where


modifiers = {
    'followers': _followers,
    'following': _following,
    'tweets': _tweet_count,
    'gender': _gender,
    'lang': _lang
}

# stur the soup of metaprogramming
docs = ''

for fn in modifiers.values():
    assert fn.__doc__ is not None

    doc = fn.__doc__.strip()
    doc = doc.replace('\n', '<br>\n') # make sure markdown2 puts newlines
    docs += markdown2.markdown(doc)


# if you think this is bad, go read the autogenerated integration tests.


# note: somewhat tollerable parser, if something *might* be a syntax error
# we let it through.
# we return (sql, args) where args is a list to be passed through asyncpg
# for serialization
def _parse_query(query: str) -> (str, str):
    sql = SEARCH_SQL_TEMPLATE

    where = ''
    query_raw = ''

    tokens = query.split(' ')
    for token in tokens:
        a = token.split(':')
        if len(a) != 2:
            query_raw += token
            continue


        stmt, val = a
        if modifiers.get(stmt) is not None:
            sql, where = modifiers[stmt](val, sql, where)

    search = 'textsearchable @@ plainto_tsquery($1)'
    orderby = 'ORDER BY ts_rank(textsearchable, plainto_tsquery($1))'
    args = [query_raw]
    if query_raw.strip() == '':
        search  = 'true' # true on all profiles
        orderby = ''
        args = []


    return sql.format(limit=LIMIT, where=where, search=search, orderby=orderby), args
